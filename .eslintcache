[{"/Users/adityav/repos/book-cricket-react-redux/src/index.js":"1","/Users/adityav/repos/book-cricket-react-redux/src/reportWebVitals.js":"2","/Users/adityav/repos/book-cricket-react-redux/src/App.js":"3","/Users/adityav/repos/book-cricket-react-redux/src/components/PickTeams.js":"4","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/store/index.js":"5","/Users/adityav/repos/book-cricket-react-redux/src/components/MatchComponent.js":"6","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/pickTeams.js":"7","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/initPickTeamsReducer.js":"8","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/setFirstTeamsReducer.js":"9","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/manageScores.js":"10","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/teamsReducer.js":"11","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/dynamicSquads.js":"12","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/dynamicSquadAction.js":"13","/Users/adityav/repos/book-cricket-react-redux/src/helpers/asyncHelper.js":"14","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/resetState.js":"15","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/completeInnings.js":"16","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/getTeamAction.js":"17","/Users/adityav/repos/book-cricket-react-redux/src/components/ScoreCard.js":"18","/Users/adityav/repos/book-cricket-react-redux/src/helpers/randomNumber.js":"19","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/scoreX.js":"20","/Users/adityav/repos/book-cricket-react-redux/src/helpers/improvedRandomNumber.js":"21","/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentSetup.js":"22","/Users/adityav/repos/book-cricket-react-redux/src/components/ModeSelection.js":"23","/Users/adityav/repos/book-cricket-react-redux/src/components/BilateralManager.js":"24","/Users/adityav/repos/book-cricket-react-redux/src/components/BilateralSetup.js":"25","/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentManager.js":"26","/Users/adityav/repos/book-cricket-react-redux/src/components/StatsTab.js":"27","/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentStandings.js":"28","/Users/adityav/repos/book-cricket-react-redux/src/components/PostMatchView.js":"29","/Users/adityav/repos/book-cricket-react-redux/src/components/MatchSetup.js":"30","/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentMatchView.js":"31","/Users/adityav/repos/book-cricket-react-redux/src/components/SingleTeamScoreCard.js":"32","/Users/adityav/repos/book-cricket-react-redux/src/helpers/matchResultHelper.js":"33","/Users/adityav/repos/book-cricket-react-redux/src/components/FixturesView.js":"34","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/simulateMatch.js":"35"},{"size":500,"mtime":1749273493789,"results":"36","hashOfConfig":"37"},{"size":364,"mtime":1749273493790,"results":"38","hashOfConfig":"37"},{"size":648,"mtime":1771229592788,"results":"39","hashOfConfig":"37"},{"size":8976,"mtime":1771224131503,"results":"40","hashOfConfig":"37"},{"size":642,"mtime":1749275501212,"results":"41","hashOfConfig":"37"},{"size":9658,"mtime":1771225080051,"results":"42","hashOfConfig":"37"},{"size":238,"mtime":1755471585056,"results":"43","hashOfConfig":"37"},{"size":460,"mtime":1749273493790,"results":"44","hashOfConfig":"37"},{"size":542,"mtime":1749273493790,"results":"45","hashOfConfig":"37"},{"size":14138,"mtime":1767592878697,"results":"46","hashOfConfig":"37"},{"size":3123,"mtime":1767593485471,"results":"47","hashOfConfig":"37"},{"size":246,"mtime":1749273493790,"results":"48","hashOfConfig":"37"},{"size":138,"mtime":1749273493789,"results":"49","hashOfConfig":"37"},{"size":256,"mtime":1749273493789,"results":"50","hashOfConfig":"37"},{"size":99,"mtime":1749273493790,"results":"51","hashOfConfig":"37"},{"size":129,"mtime":1749273493789,"results":"52","hashOfConfig":"37"},{"size":221,"mtime":1749273493790,"results":"53","hashOfConfig":"37"},{"size":3757,"mtime":1771224758524,"results":"54","hashOfConfig":"37"},{"size":5766,"mtime":1749275501212,"results":"55","hashOfConfig":"56"},{"size":164,"mtime":1749275501212,"results":"57","hashOfConfig":"37"},{"size":11888,"mtime":1772015401380,"results":"58","hashOfConfig":"37"},{"size":3458,"mtime":1771229565782,"results":"59","hashOfConfig":"37"},{"size":2311,"mtime":1771224003148,"results":"60","hashOfConfig":"37"},{"size":5052,"mtime":1771225897190,"results":"61","hashOfConfig":"37"},{"size":3601,"mtime":1771224027055,"results":"62","hashOfConfig":"37"},{"size":29830,"mtime":1771231934782,"results":"63","hashOfConfig":"37"},{"size":4237,"mtime":1771230341915,"results":"64","hashOfConfig":"37"},{"size":2940,"mtime":1771231856920,"results":"65","hashOfConfig":"37"},{"size":3317,"mtime":1771231849099,"results":"66","hashOfConfig":"37"},{"size":3303,"mtime":1771224790626,"results":"67","hashOfConfig":"37"},{"size":3640,"mtime":1771225437923,"results":"68","hashOfConfig":"37"},{"size":2450,"mtime":1771225459790,"results":"69","hashOfConfig":"37"},{"size":1416,"mtime":1771227145713,"results":"70","hashOfConfig":"37"},{"size":16557,"mtime":1772015614883,"results":"71","hashOfConfig":"37"},{"size":1682,"mtime":1771226352887,"results":"72","hashOfConfig":"37"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},"1y14lk6",{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"75"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"15xxcz8",{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"115"},{"filePath":"116","messages":"117","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"118","usedDeprecatedRules":"75"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"121","messages":"122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"123","messages":"124","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"125","usedDeprecatedRules":"75"},{"filePath":"126","messages":"127","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"128","messages":"129","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"130","usedDeprecatedRules":"75"},{"filePath":"131","messages":"132","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"133","messages":"134","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"135","messages":"136","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"137","messages":"138","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"139","messages":"140","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"141","messages":"142","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"143","messages":"144","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"145","messages":"146","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"147","messages":"148","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"149","usedDeprecatedRules":"75"},"/Users/adityav/repos/book-cricket-react-redux/src/index.js",[],["150","151"],"/Users/adityav/repos/book-cricket-react-redux/src/reportWebVitals.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/App.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/PickTeams.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/store/index.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/MatchComponent.js",["152","153"],"import React, { useEffect, useState, useRef } from \"react\";\nimport { connect } from \"react-redux\";\nimport scoreX from \"../redux-setup/actions/scoreX\";\nimport completeInnings from \"../redux-setup/actions/completeInnings\";\nimport resetState from \"../redux-setup/actions/resetState\";\nimport ScoreCard from \"./ScoreCard\";\nimport { Button } from \"@material-ui/core\";\nimport getTeamAction from \"../redux-setup/actions/getTeamAction\";\nimport { asyncHelper } from \"../helpers/asyncHelper\";\nimport dynamicSquadAction from \"../redux-setup/actions/dynamicSquadAction\";\nimport { useSelector } from \"react-redux\";\nimport { useDispatch } from \"react-redux\";\n\nfunction MatchComponent(props) {\n  const [message, setMessage] = useState(\"\");\n  const track = useRef({});\n  const dynamicSquads = useSelector((state) => state.dynamicSquads);\n  const dispatch = useDispatch();\n\n  useEffect(() => {\n    const url =\n      props.scoreData.format === \"T20\"\n        ? \"https://raw.githubusercontent.com/Ad1tyaV/pyTestFiles/master/cric-v2.json\"\n        : \"https://raw.githubusercontent.com/Ad1tyaV/pyTestFiles/master/cric-v1.json\";\n    let data;\n    if (dynamicSquads) {\n      data = asyncHelper(url);\n      data.then((response) => {\n        if (response[0] !== 200) {\n          props.teamsDispatch(\"GET_TEAM\", response[1]);\n        } else {\n          props.teamsDispatch(\"SET_TEAM\", response[1]);\n        }\n      });\n\n      dispatch(dynamicSquadAction(\"DISABLE\"));\n    }\n  }, []);\n\n  useEffect(() => {\n    const maxBalls = props.scoreData.overs * 6;\n\n    if (!props.scoreData.gameover) {\n      if (\n        props.scoreData.team1Wickets === 10 ||\n        props.scoreData.team1BallsFaced === maxBalls\n      ) {\n        if (Object.keys(track.current).length === 0) {\n          track.current = {};\n          track.current = {\n            ...track.current,\n            team1: {\n              ...track.current.team1,\n              player_1: props.scoreData.onStrike.batterIndex,\n              player_2: props.scoreData.offStrike.batterIndex,\n            },\n          };\n        }\n        props.completeInningsDispatch(\"team1\");\n      }\n    }\n    if (\n      props.scoreData.team1Wickets === 10 ||\n      props.scoreData.team1BallsFaced === maxBalls\n    ) {\n      if (props.scoreData.team2Total > props.scoreData.team1Total) {\n        track.current = {\n          ...track.current,\n          team2: {\n            ...track.current.team1,\n            player_1: props.scoreData.onStrike.batterIndex,\n            player_2: props.scoreData.offStrike.batterIndex,\n          },\n        };\n        setMessage(\n          `${props.scoreData.team2} won by ${\n            10 - props.scoreData.team2Wickets\n          } wickets`\n        );\n      } else if (\n        props.scoreData.team2Total === props.scoreData.team1Total &&\n        (props.scoreData.team2Wickets === 10 ||\n          props.scoreData.team2BallsFaced === maxBalls)\n      ) {\n        track.current = {\n          ...track.current,\n          team2: {\n            ...track.current.team1,\n            player_1: props.scoreData.onStrike.batterIndex,\n            player_2: props.scoreData.offStrike.batterIndex,\n          },\n        };\n        setMessage(`Match Tied`);\n      } else if (\n        props.scoreData.team2Total < props.scoreData.team1Total &&\n        (props.scoreData.team2Wickets === 10 ||\n          props.scoreData.team2BallsFaced === maxBalls)\n      ) {\n        track.current = {\n          ...track.current,\n          team2: {\n            ...track.current.team1,\n            player_1: props.scoreData.onStrike.batterIndex,\n            player_2: props.scoreData.offStrike.batterIndex,\n          },\n        };\n        setMessage(\n          `${props.scoreData.team1} beat ${props.scoreData.team2} by ${\n            props.scoreData.team1Total - props.scoreData.team2Total\n          } runs`\n        );\n      }\n    }\n  }, [props.scoreData]);\n\n  return (\n    <div style={{ color: \"whitesmoke\" }}>\n      {\n        <>\n          <span\n            className=\"score_data\"\n            style={{ display: \"flex\", justifyContent: \"center\" }}\n          >\n            <h3>{props.scoreData.team1}</h3>&nbsp;&nbsp;\n            <h3>\n              {props.scoreData.team1Total}/{props.scoreData.team1Wickets} Overs:\n              {Math.floor(props.scoreData.team1BallsFaced / 6)}.\n              {props.scoreData.team1BallsFaced % 6} RR:\n              {(\n                props.scoreData.team1Total /\n                ((props.scoreData.team1BallsFaced || 1) / 6)\n              ).toPrecision(3) ?? 0}\n            </h3>\n          </span>\n\n          <span\n            className=\"score_data\"\n            style={{ display: \"flex\", justifyContent: \"center\" }}\n          >\n            <h3>{props.scoreData.team2}</h3>&nbsp;&nbsp;\n            <h3>\n              {props.scoreData.team2Total}/{props.scoreData.team2Wickets} Overs:\n              {Math.floor(props.scoreData.team2BallsFaced / 6)}.\n              {props.scoreData.team2BallsFaced % 6} RR:\n              {(\n                props.scoreData.team2Total /\n                ((props.scoreData.team2BallsFaced || 1) / 6)\n              ).toPrecision(3) ?? 0}\n            </h3>\n          </span>\n        </>\n      }\n      {<br />}\n      {props.scoreData.currentTeamBatting === props.scoreData.team1 ? (\n        <div>\n          <span style={{ display: \"flex\", justifyContent: \"center\" }}>\n            {\n              props.teamData?.[props.scoreData.team1]?.[\n                props.scoreData.onStrike.batterIndex\n              ] || \"Player\"\n            }\n            üëâüèæ\n            {props.scoreData.team1Stats[props.scoreData.onStrike.batterIndex] ??\n              0}\n            (\n            {props.scoreData.team1BallsFacedByPlayer?.[\n              props.scoreData.onStrike.batterIndex\n            ] ?? 0}\n            )\n          </span>\n          <br />\n          <span style={{ display: \"flex\", justifyContent: \"center\" }}>\n            {\n              props.teamData?.[props.scoreData.team1]?.[\n                props.scoreData.offStrike.batterIndex\n              ] || \"Player\"\n            }\n            üëâüèæ\n            {props.scoreData.team1Stats[\n              props.scoreData.offStrike.batterIndex\n            ] ?? 0}\n            (\n            {props.scoreData.team1BallsFacedByPlayer?.[\n              props.scoreData.offStrike.batterIndex\n            ] ?? 0}\n            )\n          </span>\n        </div>\n      ) : (\n        <div>\n          <span style={{ display: \"flex\", justifyContent: \"center\" }}>\n            {\n              props.teamData?.[props.scoreData.team2]?.[\n                props.scoreData.onStrike.batterIndex\n              ] || \"Player\"\n            }\n            üëâüèæ\n            {props.scoreData.team2Stats[props.scoreData.onStrike.batterIndex] ??\n              0}\n            (\n            {props.scoreData.team2BallsFacedByPlayer?.[\n              props.scoreData.onStrike.batterIndex\n            ] ?? 0}\n            )\n          </span>\n          <br />\n          <span style={{ display: \"flex\", justifyContent: \"center\" }}>\n            {\n              props.teamData?.[props.scoreData.team2]?.[\n                props.scoreData.offStrike.batterIndex\n              ] || \"Player\"\n            }\n            üëâüèæ\n            {props.scoreData.team2Stats[\n              props.scoreData.offStrike.batterIndex\n            ] ?? 0}\n            (\n            {props.scoreData.team2BallsFacedByPlayer?.[\n              props.scoreData.offStrike.batterIndex\n            ] ?? 0}\n            )\n          </span>\n        </div>\n      )}\n      {<hr />}\n      {props.scoreData.gameover ? (\n        <>\n          <span\n            style={{\n              display: \"flex\",\n              justifyContent: \"center\",\n              fontWeight: \"600\",\n            }}\n          >\n            {message}\n          </span>\n          <br />\n          <span style={{ display: \"flex\", justifyContent: \"center\" }}>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => {\n                track.current = {};\n                props.resetDispatch();\n              }}\n            >\n              Play Again\n            </Button>\n          </span>\n        </>\n      ) : (\n        <span style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <Button\n            color=\"primary\"\n            variant=\"contained\"\n            onClick={() => {\n              for (let i = 0; i < 6; i++)\n                // props.scoreDispatch(Math.floor(Math.random() * 7));\n                props.scoreDispatch(props.pitchType);\n            }}\n          >\n            PLAY\n          </Button>\n        </span>\n      )}\n\n      {props.scoreData.gameover ? (\n        <ScoreCard\n          track={track.current}\n          team1={props.scoreData.team1}\n          team2={props.scoreData.team2}\n          teamData={props.teamData}\n          team1Stats={props.scoreData.team1Stats}\n          team2Stats={props.scoreData.team2Stats}\n          team1BallsFacedByPlayer={props.scoreData.team1BallsFacedByPlayer}\n          team2BallsFacedByPlayer={props.scoreData.team2BallsFacedByPlayer}\n        />\n      ) : (\n        <></>\n      )}\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => {\n  //console.log(state);\n  return {\n    scoreData: state.manageScores,\n    teamData: state.getTeams,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    scoreDispatch: (X) => dispatch(scoreX(null, X)),\n    completeInningsDispatch: (team) => dispatch(completeInnings(team)),\n    resetDispatch: () => dispatch(resetState()),\n    teamsDispatch: (type, data) => dispatch(getTeamAction(type, data)),\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MatchComponent);\n","/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/pickTeams.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/initPickTeamsReducer.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/setFirstTeamsReducer.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/manageScores.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/teamsReducer.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/reducers/dynamicSquads.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/dynamicSquadAction.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/helpers/asyncHelper.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/resetState.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/completeInnings.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/getTeamAction.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/ScoreCard.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/helpers/randomNumber.js",["154","155","156"],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/scoreX.js",[],["157","158"],"/Users/adityav/repos/book-cricket-react-redux/src/helpers/improvedRandomNumber.js",["159"],"// Realistic cricket scoring system that adapts to different formats\nconst OUTCOMES = [-1, 0, 1, 2, 3, 4, 6]; // Possible cricket outcomes\n\n// Realistic base frequencies for different formats\n// These are calibrated to produce realistic run rates\nconst FORMAT_BASE_FREQUENCIES = {\n    T20: {\n        // T20: Target ~8-9 runs per over (realistic T20 average)\n        AGGRESSIVE: [5, 45, 30, 15, 2, 18, 12],    // ~9.2 RPO\n        ANCHOR: [4, 55, 40, 18, 3, 15, 8],         // ~7.8 RPO  \n        POWER_HITTER: [8, 40, 20, 10, 1, 20, 18], // ~10.5 RPO\n        ACCUMULATOR: [3, 50, 50, 20, 4, 12, 6],   // ~7.5 RPO\n        ALL_ROUNDER: [5, 50, 35, 15, 2, 16, 10],  // ~8.5 RPO\n        TAIL_ENDER: [15, 70, 25, 8, 1, 8, 3]      // ~5.2 RPO\n    },\n    ODI_50: {\n        // ODI: Target ~5-6 runs per over (realistic ODI average)\n        AGGRESSIVE: [4, 65, 40, 18, 3, 15, 8],     // ~6.2 RPO\n        ANCHOR: [3, 75, 50, 20, 4, 12, 4],         // ~5.4 RPO\n        POWER_HITTER: [8, 60, 25, 12, 2, 18, 12], // ~7.8 RPO\n        ACCUMULATOR: [2, 70, 60, 25, 5, 10, 3],   // ~5.8 RPO\n        ALL_ROUNDER: [4, 70, 45, 18, 3, 13, 6],   // ~6.0 RPO\n        TAIL_ENDER: [12, 85, 30, 10, 2, 6, 2]     // ~3.8 RPO\n    },\n    ODI_40: {\n        // 40-over: Target ~6-7 runs per over\n        AGGRESSIVE: [4, 60, 38, 16, 3, 16, 9],     // ~6.8 RPO\n        ANCHOR: [3, 70, 48, 19, 4, 13, 5],         // ~5.9 RPO\n        POWER_HITTER: [7, 55, 23, 11, 2, 16, 11], // ~8.5 RPO\n        ACCUMULATOR: [2, 65, 55, 23, 5, 11, 4],   // ~6.2 RPO\n        ALL_ROUNDER: [4, 65, 42, 17, 3, 14, 7],   // ~6.5 RPO\n        TAIL_ENDER: [12, 80, 28, 9, 2, 7, 3]      // ~4.2 RPO\n    }\n};\n\n// Format-specific modifiers\nconst FORMAT_MODIFIERS = {\n    T20: {\n        name: \"T20\",\n        totalOvers: 20,\n        aggressionMultiplier: 1.5, // More aggressive\n        boundaryBoost: 1.4, // More 4s and 6s\n        dotPenalty: 0.7, // Fewer dot balls\n        wicketRisk: 1.3 // Higher risk of getting out\n    },\n    ODI_50: {\n        name: \"50 Over ODI\",\n        totalOvers: 50,\n        aggressionMultiplier: 1.0, // Balanced\n        boundaryBoost: 1.0,\n        dotPenalty: 1.0,\n        wicketRisk: 1.0\n    },\n    ODI_40: {\n        name: \"40 Over ODI\",\n        totalOvers: 40,\n        aggressionMultiplier: 1.2, // Slightly more aggressive\n        boundaryBoost: 1.15,\n        dotPenalty: 0.85,\n        wicketRisk: 1.1\n    },\n    TEST: {\n        name: \"Test Match\",\n        totalOvers: 90, // Typical day's play\n        aggressionMultiplier: 0.6, // Very conservative\n        boundaryBoost: 0.7,\n        dotPenalty: 1.4, // More dot balls acceptable\n        wicketRisk: 0.7 // Lower risk tolerance\n    }\n};\n\n// Pitch condition modifiers - adjusted difficulties\nconst PITCH_MODIFIERS = {\n    NORMAL: { wicket: 0, dot: 0, single: 0, two: 0, three: 0, four: 0, six: 0 },\n    GREEN: { wicket: 2, dot: 6, single: 4, two: 1, three: 0, four: -2, six: -3 }, // Difficulty 7\n    HARD: { wicket: -2, dot: -6, single: -2, two: 1, three: 0, four: 4, six: 5 }, // Difficulty 2\n    WET: { wicket: 1, dot: 6, single: 4, two: 2, three: 0, four: -2, six: -5 }, // Difficulty 6 (reduced from 8)\n    // Dusty stays distinct from Normal: more attritional, fewer boundaries.\n    DUSTY: { wicket: 2, dot: 8, single: -2, two: -1, three: 0, four: -2, six: -3 }\n};\n\n// Format+pitch tuning to avoid inflated totals in specific combinations.\n// ODI_40 + Normal was producing unusually high totals, so we soften boundary rate.\nconst FORMAT_PITCH_TUNING = {\n    ODI_40: {\n        NORMAL: { wicket: 1, dot: 5, single: -1, two: -1, three: 0, four: -2, six: -3 }\n    }\n};\n\nconst EXPECTED_RUN_RATE = {\n    T20: 8.6,\n    ODI_40: 6.2,\n    ODI_50: 5.7,\n    TEST: 3.4\n};\n\nconst applyFrequencyDelta = (frequency, delta) => {\n    frequency[0] += delta.wicket || 0;\n    frequency[1] += delta.dot || 0;\n    frequency[2] += delta.single || 0;\n    frequency[3] += delta.two || 0;\n    frequency[4] += delta.three || 0;\n    frequency[5] += delta.four || 0;\n    frequency[6] += delta.six || 0;\n};\n\nconst applyConsistencyAdjustments = (frequency, format, gameState = {}) => {\n    const ballsFaced = gameState.ballsFaced || 0;\n    const currentScore = gameState.currentScore || 0;\n    const wicketsLost = gameState.wicketsLost || 0;\n    const targetScore = gameState.targetScore || null;\n    const totalBalls = FORMAT_MODIFIERS[format]?.totalOvers * 6 || 300;\n\n    if (ballsFaced <= 0) return frequency;\n\n    const progress = ballsFaced / totalBalls;\n    const currentRunRate = currentScore / (ballsFaced / 6);\n    const expectedRate = EXPECTED_RUN_RATE[format] || EXPECTED_RUN_RATE.ODI_50;\n\n    // Prevent dramatic collapses too early/often.\n    if (wicketsLost >= 5 && progress < 0.8) {\n        applyFrequencyDelta(frequency, { wicket: -4, dot: -3, single: 4, two: 1, four: 1, six: 0 });\n    }\n\n    // Pull down unrealistic hitting streaks to avoid excessive totals.\n    if (currentRunRate > expectedRate + 1.8 && progress < 0.9) {\n        applyFrequencyDelta(frequency, { wicket: 1, dot: 4, single: 2, two: 0, four: -3, six: -4 });\n    }\n\n    // Lift unrealistically low-scoring phases if wickets are still in hand.\n    if (currentRunRate < expectedRate - 1.8 && wicketsLost <= 7 && progress > 0.2) {\n        applyFrequencyDelta(frequency, { wicket: -2, dot: -4, single: 4, two: 2, four: 1, six: 0 });\n    }\n\n    // Chasing logic: reduce boom-bust behavior when required rate is manageable.\n    if (targetScore) {\n        const runsNeeded = targetScore - currentScore;\n        const ballsRemaining = Math.max(1, totalBalls - ballsFaced);\n        const requiredRate = (runsNeeded * 6) / ballsRemaining;\n\n        if (requiredRate <= expectedRate + 1 && wicketsLost >= 4) {\n            applyFrequencyDelta(frequency, { wicket: -3, dot: -1, single: 3, two: 1, four: -1, six: -2 });\n        } else if (requiredRate > expectedRate + 2.5) {\n            applyFrequencyDelta(frequency, { wicket: 1, dot: -1, single: -1, two: 1, four: 2, six: 2 });\n        }\n    }\n\n    return frequency;\n};\n\n// Game situation modifiers\nconst getSituationModifier = (ballsFaced, totalBalls, currentScore, targetScore = null, wicketsLost) => {\n    const oversRemaining = (totalBalls - ballsFaced) / 6;\n    const wicketsInHand = 10 - wicketsLost;\n\n    let aggressionFactor = 1.0;\n    let riskFactor = 1.0;\n\n    // Death overs (last 10% of innings)\n    if (ballsFaced > totalBalls * 0.9) {\n        aggressionFactor = 1.8;\n        riskFactor = 1.4;\n    }\n    // Middle overs (40-80% of innings)  \n    else if (ballsFaced > totalBalls * 0.4 && ballsFaced < totalBalls * 0.8) {\n        aggressionFactor = 0.8;\n        riskFactor = 0.8;\n    }\n    // Powerplay (first 20% of innings)\n    else if (ballsFaced < totalBalls * 0.2) {\n        aggressionFactor = 1.3;\n        riskFactor = 1.1;\n    }\n\n    // Chasing scenario\n    if (targetScore) {\n        const requiredRate = (targetScore - currentScore) / oversRemaining;\n        const currentRate = currentScore / (ballsFaced / 6);\n\n        if (requiredRate > currentRate * 1.5) {\n            aggressionFactor *= 2.0; // Desperate situation\n            riskFactor *= 1.8;\n        } else if (requiredRate > currentRate * 1.2) {\n            aggressionFactor *= 1.4; // Need to accelerate\n            riskFactor *= 1.2;\n        }\n    }\n\n    // Wickets in hand factor\n    if (wicketsInHand <= 3) {\n        riskFactor *= 0.6; // Play safe with few wickets\n        aggressionFactor *= 0.7;\n    } else if (wicketsInHand >= 7) {\n        riskFactor *= 1.2; // Can afford risks\n        aggressionFactor *= 1.1;\n    }\n\n    return { aggressionFactor, riskFactor };\n};\n\n// Simplified realistic function - no complex multipliers\nconst getImprovedRandomOutcome = (\n    playerArchetype,\n    format,\n    pitchType = 'NORMAL',\n    gameState = {}\n) => {\n    // Get the realistic base frequency for this format and player type\n    const formatFreqs = FORMAT_BASE_FREQUENCIES[format] || FORMAT_BASE_FREQUENCIES.ODI_50;\n    const baseFreq = formatFreqs[playerArchetype] || formatFreqs.ALL_ROUNDER;\n\n    // Start with the realistic base frequency\n    let frequency = [...baseFreq];\n\n    // Apply only pitch modifiers (small adjustments)\n    const pitchMod = PITCH_MODIFIERS[pitchType] || PITCH_MODIFIERS.NORMAL;\n    applyFrequencyDelta(frequency, pitchMod);\n\n    // Apply targeted format+pitch calibration, if configured.\n    const formatPitchMod = FORMAT_PITCH_TUNING[format]?.[pitchType];\n    if (formatPitchMod) {\n        applyFrequencyDelta(frequency, formatPitchMod);\n    }\n\n    // Use current innings state to reduce extreme match-to-match volatility.\n    applyConsistencyAdjustments(frequency, format, gameState);\n\n    // Ensure no negative frequencies\n    frequency = frequency.map(f => Math.max(0, Math.round(f)));\n\n    // Create cumulative sum for weighted selection\n    const cumulativeSum = ((sum) => (value) => (sum += value))(0);\n    const prefixSum = frequency.map(cumulativeSum);\n    const totalWeight = prefixSum[prefixSum.length - 1];\n\n    if (totalWeight === 0) return 1; // Fallback\n\n    // Generate random outcome\n    const random = Math.floor(Math.random() * totalWeight);\n\n    // Find which outcome was selected\n    for (let i = 0; i < prefixSum.length; i++) {\n        if (random < prefixSum[i]) {\n            return OUTCOMES[i];\n        }\n    }\n\n    return OUTCOMES[OUTCOMES.length - 1]; // Fallback to six\n};\n\n// Helper function to assign player archetypes based on batting position\nconst getPlayerArchetypeByPosition = (batterIndex, format) => {\n    // Different batting orders for different formats\n    // Position 6 (index 6) is now POWER_HITTER for faster scoring (Jadeja fix)\n    const archetypesByPosition = {\n        T20: ['AGGRESSIVE', 'AGGRESSIVE', 'ANCHOR', 'POWER_HITTER', 'ALL_ROUNDER', 'POWER_HITTER', 'POWER_HITTER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER'],\n        ODI_50: ['ANCHOR', 'AGGRESSIVE', 'ANCHOR', 'ACCUMULATOR', 'ALL_ROUNDER', 'AGGRESSIVE', 'POWER_HITTER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER'],\n        ODI_40: ['AGGRESSIVE', 'ANCHOR', 'ANCHOR', 'ALL_ROUNDER', 'AGGRESSIVE', 'POWER_HITTER', 'POWER_HITTER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER'],\n        TEST: ['ANCHOR', 'ANCHOR', 'ACCUMULATOR', 'ANCHOR', 'ALL_ROUNDER', 'ALL_ROUNDER', 'POWER_HITTER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER', 'TAIL_ENDER']\n    };\n\n    const positions = archetypesByPosition[format] || archetypesByPosition.ODI_50;\n    return positions[Math.min(batterIndex + 1, positions.length - 1)] || 'ALL_ROUNDER';\n};\n\n// Export the main function with backward compatibility\nconst RandomWithIndex = (batterIndex, pitchType = 'Normal', format = 'ODI_50', gameState = {}) => {\n    const playerArchetype = getPlayerArchetypeByPosition(batterIndex, format);\n\n    // Map pitch types from game format to system format\n    const pitchTypeMap = {\n        'Normal': 'NORMAL',\n        'Green': 'GREEN',\n        'Hard': 'HARD',\n        'Wet': 'WET',\n        'Dusty': 'DUSTY'\n    };\n\n    const mappedPitchType = pitchTypeMap[pitchType] || 'NORMAL';\n    return getImprovedRandomOutcome(playerArchetype, format, mappedPitchType, gameState);\n};\n\nexport default RandomWithIndex;\n// Create PLAYER_ARCHETYPES for backward compatibility with demo\nconst PLAYER_ARCHETYPES = {\n    AGGRESSIVE: { name: \"Aggressive\", description: \"High strike rate, takes risks\" },\n    ANCHOR: { name: \"Anchor\", description: \"Builds innings, rotates strike\" },\n    POWER_HITTER: { name: \"Power Hitter\", description: \"Big hitting, high risk\" },\n    ACCUMULATOR: { name: \"Accumulator\", description: \"Consistent run scoring\" },\n    ALL_ROUNDER: { name: \"All Rounder\", description: \"Versatile batting style\" },\n    TAIL_ENDER: { name: \"Tail Ender\", description: \"Lower order batsman\" }\n};\n\nexport {\n    getImprovedRandomOutcome,\n    PLAYER_ARCHETYPES,\n    FORMAT_MODIFIERS,\n    PITCH_MODIFIERS,\n    getPlayerArchetypeByPosition,\n    FORMAT_BASE_FREQUENCIES\n};\n","/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentSetup.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/ModeSelection.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/BilateralManager.js",["160"],"import React, { useState, useEffect } from \"react\";\nimport { connect } from \"react-redux\";\nimport pickTeams from \"../redux-setup/actions/pickTeams\";\nimport resetState from \"../redux-setup/actions/resetState\";\nimport MatchComponent from \"./MatchComponent\";\nimport MatchSetup from \"./MatchSetup\";\nimport { Button } from \"@material-ui/core\";\nimport { getMatchResult } from \"../helpers/matchResultHelper\";\n\nfunction BilateralManager({ config, onExit, scoreData, pickTeamDispatch, resetDispatch }) {\n  const [currentMatch, setCurrentMatch] = useState(1);\n  const [seriesScore, setSeriesScore] = useState({ team1: 0, team2: 0 });\n  const [matchResults, setMatchResults] = useState([]);\n  const [matchSetupPending, setMatchSetupPending] = useState(true);\n  const [currentPitchType, setCurrentPitchType] = useState(\"Normal\");\n\n  useEffect(() => {\n    // Don't auto-start, wait for match setup\n  }, []);\n\n  useEffect(() => {\n    if (scoreData.gameover && currentMatch <= config.numMatches && !matchSetupPending) {\n      // Update series score\n      const team1Won = scoreData.team1Total > scoreData.team2Total;\n      const team2Won = scoreData.team2Total > scoreData.team1Total;\n      \n      const newSeriesScore = {\n        team1: seriesScore.team1 + (team1Won ? 1 : 0),\n        team2: seriesScore.team2 + (team2Won ? 1 : 0)\n      };\n      \n      setSeriesScore(newSeriesScore);\n      \n      // Record match result\n      const result = {\n        matchNum: currentMatch,\n        team1Score: `${scoreData.team1Total}/${scoreData.team1Wickets}`,\n        team2Score: `${scoreData.team2Total}/${scoreData.team2Wickets}`,\n        winner: team1Won ? scoreData.team1 : (team2Won ? scoreData.team2 : \"Tie\"),\n        result: getMatchResult(scoreData)\n      };\n      setMatchResults([...matchResults, result]);\n    }\n  }, [scoreData.gameover]);\n\n  const handleMatchStart = (matchConfig) => {\n    const { pitchType, battingFirst } = matchConfig;\n    \n    // Determine team order based on toss\n    const team1 = battingFirst;\n    const team2 = battingFirst === config.team1 ? config.team2 : config.team1;\n    \n    setCurrentPitchType(pitchType);\n    pickTeamDispatch(team1, team2, config.overs, config.format);\n    setMatchSetupPending(false);\n  };\n\n  const handleNextMatch = () => {\n    if (currentMatch < config.numMatches) {\n      setCurrentMatch(currentMatch + 1);\n      setMatchSetupPending(true);\n      resetDispatch();\n    }\n  };\n\n  const isSeriesComplete = currentMatch === config.numMatches && scoreData.gameover;\n  const seriesWinner = seriesScore.team1 > seriesScore.team2 ? config.team1 : \n                       seriesScore.team2 > seriesScore.team1 ? config.team2 : \"Series Tied\";\n\n  // Show match setup\n  if (matchSetupPending) {\n    return (\n      <div>\n        <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n          <h3>Match {currentMatch} of {config.numMatches}</h3>\n          <p>Series Score: {config.team1} {seriesScore.team1} - {seriesScore.team2} {config.team2}</p>\n        </div>\n        <MatchSetup \n          match={{ team1: config.team1, team2: config.team2, stage: `Match ${currentMatch}` }}\n          onStartMatch={handleMatchStart}\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n        <h3>Match {currentMatch} of {config.numMatches}</h3>\n        <p>Series Score: {config.team1} {seriesScore.team1} - {seriesScore.team2} {config.team2}</p>\n      </div>\n      \n      {scoreData.team1 && (\n        <MatchComponent pitchType={currentPitchType} />\n      )}\n      \n      {scoreData.gameover && (\n        <div style={{ textAlign: \"center\", marginTop: 20, color: \"whitesmoke\" }}>\n          {!isSeriesComplete ? (\n            <Button \n              variant=\"contained\" \n              color=\"primary\" \n              onClick={handleNextMatch}\n              style={{ marginRight: 10 }}\n            >\n              Next Match\n            </Button>\n          ) : (\n            <div>\n              <h2>Series Complete!</h2>\n              <h3>{seriesWinner} wins the series {seriesScore.team1}-{seriesScore.team2}</h3>\n              <div style={{ marginTop: 20 }}>\n                <h4>Match Results:</h4>\n                {matchResults.map((result, index) => (\n                  <p key={index}>\n                    Match {result.matchNum}: {result.result}\n                  </p>\n                ))}\n              </div>\n            </div>\n          )}\n          <Button variant=\"outlined\" style={{ color: \"whitesmoke\", marginTop: 10 }} onClick={onExit}>\n            Exit Series\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  scoreData: state.manageScores\n});\n\nconst mapDispatchToProps = (dispatch) => ({\n  pickTeamDispatch: (team1, team2, overs, format) => dispatch(pickTeams(team1, team2, overs, format)),\n  resetDispatch: () => dispatch(resetState())\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(BilateralManager);\n","/Users/adityav/repos/book-cricket-react-redux/src/components/BilateralSetup.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentManager.js",["161","162","163"],"import React, { useState, useEffect } from \"react\";\nimport { connect } from \"react-redux\";\nimport pickTeams from \"../redux-setup/actions/pickTeams\";\nimport resetState from \"../redux-setup/actions/resetState\";\nimport simulateMatch from \"../redux-setup/actions/simulateMatch\";\nimport MatchSetup from \"./MatchSetup\";\nimport TournamentMatchView from \"./TournamentMatchView\";\nimport PostMatchView from \"./PostMatchView\";\nimport FixturesView from \"./FixturesView\";\nimport TournamentStandings from \"./TournamentStandings\";\nimport StatsTab from \"./StatsTab\";\nimport { Button, Tabs, Tab } from \"@material-ui/core\";\n\nfunction TournamentManager({ config, onExit, scoreData, pickTeamDispatch, resetDispatch, simulateMatchDispatch, teamData }) {\n  const [currentMatchIndex, setCurrentMatchIndex] = useState(0);\n  const [matches, setMatches] = useState([]);\n  const [standings, setStandings] = useState([]);\n  const [playerStats, setPlayerStats] = useState([]);\n  const [currentStage, setCurrentStage] = useState(\"Group Stage\");\n  const [matchSetupPending, setMatchSetupPending] = useState(true);\n  const [currentMatchConfig, setCurrentMatchConfig] = useState(null);\n  const [track, setTrack] = useState({});\n  const [completedMatches, setCompletedMatches] = useState({});\n  const [showFixtures, setShowFixtures] = useState(false);\n  const [isSimulating, setIsSimulating] = useState(false);\n  const [viewingMatchKey, setViewingMatchKey] = useState(null);\n  const [simulatingMatchIndex, setSimulatingMatchIndex] = useState(null);\n  const [simulationQueue, setSimulationQueue] = useState([]);\n  const [showTournamentSummary, setShowTournamentSummary] = useState(false);\n  const [summaryTab, setSummaryTab] = useState(0);\n\n  const getMatchKey = (stage, index) => `${stage}-${index}`;\n  const currentStageCompletedMatches = matches.reduce((acc, match, index) => {\n    const key = getMatchKey(currentStage, index);\n    if (completedMatches[key]) {\n      acc[index] = completedMatches[key];\n    }\n    return acc;\n  }, {});\n  const finishedFixtures = Object.values(completedMatches);\n  const isTournamentComplete =\n    currentStage === \"Final\" &&\n    matches.length === 1 &&\n    Boolean(completedMatches[getMatchKey(\"Final\", 0)]);\n\n  const getTournamentOutcome = (matchScore, stageName) => {\n    const { team1, team2, team1Total, team2Total, team1Wickets, team2Wickets } = matchScore;\n    const isGroupStage = stageName.includes(\"Group\");\n    const isFinal = stageName === \"Final\";\n    const isSemiFinal = stageName === \"Semi-Final\";\n\n    if (team1Total > team2Total) {\n      const runMargin = team1Total - team2Total;\n      return {\n        result: `${team1} won by ${runMargin} run${runMargin !== 1 ? \"s\" : \"\"}`,\n        winner: team1,\n        noResult: false\n      };\n    }\n\n    if (team2Total > team1Total) {\n      const wicketsRemaining = 10 - team2Wickets;\n      return {\n        result: `${team2} won by ${wicketsRemaining} wicket${wicketsRemaining !== 1 ? \"s\" : \"\"}`,\n        winner: team2,\n        noResult: false\n      };\n    }\n\n    if (isGroupStage) {\n      return {\n        result: \"No Result (Scores Level)\",\n        winner: null,\n        noResult: true\n      };\n    }\n\n    if (team1Wickets < team2Wickets) {\n      return {\n        result: `${team1} won (scores level, fewer wickets lost: ${team1Wickets} vs ${team2Wickets})`,\n        winner: team1,\n        noResult: false\n      };\n    }\n\n    if (team2Wickets < team1Wickets) {\n      return {\n        result: `${team2} won (scores level, fewer wickets lost: ${team2Wickets} vs ${team1Wickets})`,\n        winner: team2,\n        noResult: false\n      };\n    }\n\n    if (isFinal) {\n      return {\n        result: `Final tied: ${team1} and ${team2} are joint winners`,\n        winner: null,\n        noResult: false\n      };\n    }\n\n    if (isSemiFinal) {\n      const randomWinner = Math.random() > 0.5 ? team1 : team2;\n      return {\n        result: `Semi-Final tied (same runs and wickets): ${randomWinner} advance by random draw`,\n        winner: randomWinner,\n        noResult: false\n      };\n    }\n\n    return { result: \"Match Tied\", winner: null, noResult: false };\n  };\n\n  useEffect(() => {\n    // Initialize tournament\n    const teams = [...config.teams]; // Copy array\n    const numTeams = teams.length;\n    \n    // Randomize team order\n    for (let i = teams.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [teams[i], teams[j]] = [teams[j], teams[i]];\n    }\n    \n    let groupMatches = [];\n    \n    // Check if even number of teams for group stage split\n    if (numTeams % 2 === 0 && numTeams >= 4) {\n      // Split into two groups\n      const groupA = teams.slice(0, numTeams / 2);\n      const groupB = teams.slice(numTeams / 2);\n      \n      // Generate matches within Group A\n      for (let i = 0; i < groupA.length; i++) {\n        for (let j = i + 1; j < groupA.length; j++) {\n          groupMatches.push({\n            team1: groupA[i],\n            team2: groupA[j],\n            stage: \"Group A\",\n            group: \"A\"\n          });\n        }\n      }\n      \n      // Generate matches within Group B\n      for (let i = 0; i < groupB.length; i++) {\n        for (let j = i + 1; j < groupB.length; j++) {\n          groupMatches.push({\n            team1: groupB[i],\n            team2: groupB[j],\n            stage: \"Group B\",\n            group: \"B\"\n          });\n        }\n      }\n    } else {\n      // Round-robin for odd number of teams\n      for (let i = 0; i < teams.length; i++) {\n        for (let j = i + 1; j < teams.length; j++) {\n          groupMatches.push({\n            team1: teams[i],\n            team2: teams[j],\n            stage: \"Group Stage\",\n            group: \"ALL\"\n          });\n        }\n      }\n    }\n\n    setMatches(groupMatches);\n    \n    // Initialize standings\n    const initialStandings = teams.map(team => ({\n      name: team,\n      played: 0,\n      won: 0,\n      lost: 0,\n      noResult: 0,\n      nrr: 0,\n      points: 0,\n      runsScored: 0,\n      ballsFaced: 0,\n      runsConceded: 0,\n      ballsBowled: 0,\n      group: numTeams % 2 === 0 ? \n        (teams.indexOf(team) < numTeams / 2 ? \"A\" : \"B\") : \n        \"ALL\"\n    }));\n    setStandings(initialStandings);\n    \n    // Set first match for setup\n    if (groupMatches.length > 0) {\n      setCurrentMatchConfig(groupMatches[0]);\n    }\n  }, [config.teams]);\n\n  useEffect(() => {\n    // Check if current match is over\n    if (scoreData.gameover && !matchSetupPending && matches.length > 0) {\n      // Only update if not already saved\n      const currentMatchKey = getMatchKey(currentStage, currentMatchIndex);\n      if (!completedMatches[currentMatchKey]) {\n        const outcome = getTournamentOutcome(scoreData, currentStage);\n        updateStandingsAndStats(outcome);\n        \n        // Save track data\n        const currentTrack = {\n          team1: { player_1: scoreData.onStrike.batterIndex, player_2: scoreData.offStrike.batterIndex },\n          team2: { player_1: scoreData.onStrike.batterIndex, player_2: scoreData.offStrike.batterIndex }\n        };\n        \n        setTrack(currentTrack);\n        \n        // Save completed match result with full scoreData\n        const matchResult = {\n          key: currentMatchKey,\n          stage: currentStage,\n          matchIndex: currentMatchIndex,\n          team1: scoreData.team1,\n          team2: scoreData.team2,\n          team1Score: `${scoreData.team1Total}/${scoreData.team1Wickets}`,\n          team2Score: `${scoreData.team2Total}/${scoreData.team2Wickets}`,\n          result: outcome.result,\n          winner: outcome.winner,\n          noResult: outcome.noResult,\n          completedAt: Date.now(),\n          // Store full match data for viewing later\n          scoreData: {\n            team1: scoreData.team1,\n            team2: scoreData.team2,\n            team1Total: scoreData.team1Total,\n            team2Total: scoreData.team2Total,\n            team1Wickets: scoreData.team1Wickets,\n            team2Wickets: scoreData.team2Wickets,\n            team1Stats: { ...scoreData.team1Stats },\n            team2Stats: { ...scoreData.team2Stats },\n            team1BallsFacedByPlayer: { ...scoreData.team1BallsFacedByPlayer },\n            team2BallsFacedByPlayer: { ...scoreData.team2BallsFacedByPlayer }\n          },\n          track: currentTrack\n        };\n        \n        setCompletedMatches(prev => ({\n          ...prev,\n          [currentMatchKey]: matchResult\n        }));\n      }\n      \n      // Always reset simulation state when match is over\n      setIsSimulating(false);\n      setSimulatingMatchIndex(null);\n    }\n  }, [scoreData.gameover, matchSetupPending, matches.length, currentMatchIndex, currentStage, completedMatches]);\n\n  useEffect(() => {\n    if (isSimulating || matches.length === 0) return;\n\n    const allMatchesCompleted = matches.every((_, index) =>\n      Boolean(completedMatches[getMatchKey(currentStage, index)])\n    );\n    if (!allMatchesCompleted) return;\n\n    if (currentStage.includes(\"Group\")) {\n      generateSemiFinals();\n      return;\n    }\n\n    if (currentStage === \"Semi-Final\") {\n      const winners = matches\n        .map((_, index) => completedMatches[getMatchKey(currentStage, index)]?.winner)\n        .filter(Boolean);\n\n      if (winners.length === 2) {\n        generateFinal(winners);\n      }\n    }\n  }, [completedMatches, matches, currentStage, isSimulating]);\n\n  useEffect(() => {\n    if (isSimulating || simulationQueue.length === 0) return;\n    const [nextMatchIndex, ...remainingQueue] = simulationQueue;\n    setSimulationQueue(remainingQueue);\n    handleSimulateMatch(nextMatchIndex);\n  }, [isSimulating, simulationQueue]);\n\n  const updateStandingsAndStats = (outcome) => {\n    // Use actual teams from scoreData (which reflects the toss decision)\n    const team1 = scoreData.team1;  // Team that batted first\n    const team2 = scoreData.team2;  // Team that batted second\n    const team1Score = scoreData.team1Total;\n    const team2Score = scoreData.team2Total;\n    const team1Balls = scoreData.team1BallsFaced;\n    const team2Balls = scoreData.team2BallsFaced;\n\n    // Knockout matches should not affect league standings table.\n    if (currentStage.includes(\"Group\")) {\n      const newStandings = standings.map(team => {\n        if (team.name === team1) {\n          const won = outcome.winner === team1 ? 1 : 0;\n          const lost = outcome.winner === team2 ? 1 : 0;\n          const noResult = outcome.noResult ? 1 : 0;\n          return {\n            ...team,\n            played: team.played + 1,\n            won: team.won + won,\n            lost: team.lost + lost,\n            noResult: team.noResult + noResult,\n            points: team.points + (won * 2) + (noResult * 1),\n            runsScored: team.runsScored + team1Score,\n            ballsFaced: team.ballsFaced + team1Balls,\n            runsConceded: team.runsConceded + team2Score,\n            ballsBowled: team.ballsBowled + team2Balls\n          };\n        } else if (team.name === team2) {\n          const won = outcome.winner === team2 ? 1 : 0;\n          const lost = outcome.winner === team1 ? 1 : 0;\n          const noResult = outcome.noResult ? 1 : 0;\n          return {\n            ...team,\n            played: team.played + 1,\n            won: team.won + won,\n            lost: team.lost + lost,\n            noResult: team.noResult + noResult,\n            points: team.points + (won * 2) + (noResult * 1),\n            runsScored: team.runsScored + team2Score,\n            ballsFaced: team.ballsFaced + team2Balls,\n            runsConceded: team.runsConceded + team1Score,\n            ballsBowled: team.ballsBowled + team1Balls\n          };\n        }\n        return team;\n      });\n\n      newStandings.forEach(team => {\n        const runRate = team.ballsFaced > 0 ? (team.runsScored / team.ballsFaced) * 6 : 0;\n        const concededRate = team.ballsBowled > 0 ? (team.runsConceded / team.ballsBowled) * 6 : 0;\n        team.nrr = runRate - concededRate;\n      });\n\n      setStandings(newStandings);\n    }\n\n    // Update player stats for both teams at once\n    updatePlayerStatsForMatch(team1, team2, scoreData.team1Stats, scoreData.team2Stats, scoreData.team1BallsFacedByPlayer, scoreData.team2BallsFacedByPlayer);\n  };\n\n  const updatePlayerStatsForMatch = (team1Name, team2Name, team1Stats, team2Stats, team1Balls, team2Balls) => {\n    const newPlayerStats = [...playerStats];\n    \n    // Update team 1 players\n    Object.keys(team1Stats).forEach(playerIndex => {\n      const playerName = teamData[team1Name]?.[playerIndex];\n      const runs = team1Stats[playerIndex] || 0;\n      const balls = team1Balls[playerIndex] || 0;\n      \n      if (playerName && runs > 0) {\n        const existingPlayer = newPlayerStats.find(p => p.name === playerName && p.team === team1Name);\n        if (existingPlayer) {\n          existingPlayer.runs += runs;\n          existingPlayer.balls += balls;\n          existingPlayer.strikeRate = (existingPlayer.runs / existingPlayer.balls) * 100;\n        } else {\n          newPlayerStats.push({\n            name: playerName,\n            team: team1Name,\n            runs: runs,\n            balls: balls,\n            strikeRate: (runs / balls) * 100\n          });\n        }\n      }\n    });\n    \n    // Update team 2 players\n    Object.keys(team2Stats).forEach(playerIndex => {\n      const playerName = teamData[team2Name]?.[playerIndex];\n      const runs = team2Stats[playerIndex] || 0;\n      const balls = team2Balls[playerIndex] || 0;\n      \n      if (playerName && runs > 0) {\n        const existingPlayer = newPlayerStats.find(p => p.name === playerName && p.team === team2Name);\n        if (existingPlayer) {\n          existingPlayer.runs += runs;\n          existingPlayer.balls += balls;\n          existingPlayer.strikeRate = (existingPlayer.runs / existingPlayer.balls) * 100;\n        } else {\n          newPlayerStats.push({\n            name: playerName,\n            team: team2Name,\n            runs: runs,\n            balls: balls,\n            strikeRate: (runs / balls) * 100\n          });\n        }\n      }\n    });\n    \n    setPlayerStats(newPlayerStats);\n  };\n\n  const handleMatchStart = (matchConfig) => {\n    const { pitchType, battingFirst } = matchConfig;\n    const match = currentMatchConfig;\n    \n    // Determine team order based on toss\n    const team1 = battingFirst;\n    const team2 = battingFirst === match.team1 ? match.team2 : match.team1;\n    \n    pickTeamDispatch(team1, team2, config.overs, config.format);\n    setMatchSetupPending(false);\n    setShowFixtures(false);\n    setSimulationQueue([]);\n    \n    // Store pitch type AND the actual playing order for this match\n    setCurrentMatchConfig({ \n      ...match, \n      pitchType,\n      actualTeam1: team1,  // Team batting first\n      actualTeam2: team2   // Team batting second\n    });\n  };\n\n  const handleSimulateMatch = (matchIndex) => {\n    // Auto-select random pitch and toss\n    const pitchTypes = [\"Normal\", \"Hard\", \"Wet\", \"Green\", \"Dusty\"];\n    const randomPitch = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];\n    const match = matches[matchIndex];\n    const tossWinner = Math.random() > 0.5 ? match.team1 : match.team2;\n    const tossDecision = Math.random() > 0.5 ? \"bat\" : \"bowl\";\n    const battingFirst = tossDecision === \"bat\" ? tossWinner : \n                         (tossWinner === match.team1 ? match.team2 : match.team1);\n    \n    const team1 = battingFirst;\n    const team2 = battingFirst === match.team1 ? match.team2 : match.team1;\n    \n    // Set current match index and show simulation in progress\n    setCurrentMatchIndex(matchIndex);\n    setSimulatingMatchIndex(matchIndex);\n    setIsSimulating(true);\n    setMatchSetupPending(false);\n    // Keep fixtures view open to show progress\n    \n    // Start the match\n    pickTeamDispatch(team1, team2, config.overs, config.format);\n    \n    setCurrentMatchConfig({ \n      ...match, \n      pitchType: randomPitch,\n      actualTeam1: team1,\n      actualTeam2: team2\n    });\n    \n    // Simulate full match after teams are picked and state is ready\n    setTimeout(() => {\n      simulateMatchDispatch(randomPitch);\n    }, 200);\n  };\n\n  const handleSelectMatch = (matchIndex) => {\n    setSimulationQueue([]);\n    const matchKey = getMatchKey(currentStage, matchIndex);\n    if (completedMatches[matchKey]) {\n      // Show completed match details\n      setViewingMatchKey(matchKey);\n      setShowFixtures(false);\n    } else if (matchIndex === currentMatchIndex && scoreData.team1 && !scoreData.gameover) {\n      // Resume current match in progress\n      setShowFixtures(false);\n      setViewingMatchKey(null);\n    } else {\n      // Start a new match\n      setCurrentMatchIndex(matchIndex);\n      setCurrentMatchConfig(matches[matchIndex]);\n      setMatchSetupPending(true);\n      setShowFixtures(false);\n      setViewingMatchKey(null);\n    }\n  };\n\n  const handleNextMatch = () => {\n    setSimulationQueue([]);\n    const nextIndex = currentMatchIndex + 1;\n\n    if (nextIndex < matches.length) {\n      // Continue with current stage\n      setCurrentMatchIndex(nextIndex);\n      setCurrentMatchConfig(matches[nextIndex]);\n      setMatchSetupPending(true);\n      setIsSimulating(false); // Reset simulation state\n      resetDispatch();\n    } else if (currentStage.includes(\"Group\")) {\n      // Group stage complete, generate semi-finals\n      generateSemiFinals();\n    } else if (currentStage === \"Semi-Final\") {\n      const winners = matches\n        .map((_, index) => completedMatches[getMatchKey(currentStage, index)]?.winner)\n        .filter(Boolean);\n      if (winners.length === 2) {\n        generateFinal(winners);\n      }\n    } else if (currentStage === \"Final\") {\n      setShowTournamentSummary(true);\n    }\n  };\n\n  const moveToStage = (stageMatches, stageName) => {\n    setMatches(stageMatches);\n    setCurrentMatchIndex(0);\n    setCurrentStage(stageName);\n    setCurrentMatchConfig(stageMatches[0] || null);\n    setMatchSetupPending(true);\n    setViewingMatchKey(null);\n    setSimulatingMatchIndex(null);\n    setSimulationQueue([]);\n    setIsSimulating(false);\n    setShowTournamentSummary(false);\n    resetDispatch();\n  };\n\n  const generateSemiFinals = () => {\n    const sortedStandings = [...standings].sort((a, b) => {\n      if (b.points !== a.points) return b.points - a.points;\n      return b.nrr - a.nrr;\n    });\n    \n    let semiFinals = [];\n    \n    if (standings[0].group === \"ALL\") {\n      // Single group - top 4 teams\n      if (sortedStandings.length >= 4) {\n        semiFinals = [\n          { team1: sortedStandings[0].name, team2: sortedStandings[3].name, stage: \"Semi-Final 1\" },\n          { team1: sortedStandings[1].name, team2: sortedStandings[2].name, stage: \"Semi-Final 2\" }\n        ];\n      }\n    } else {\n      // Two groups - top team from each group (for 4-team tournament)\n      const groupAStandings = sortedStandings.filter(t => t.group === \"A\");\n      const groupBStandings = sortedStandings.filter(t => t.group === \"B\");\n      \n      // For 4-team tournament (2 teams per group), top 1 from each group goes to final directly\n      if (groupAStandings.length === 2 && groupBStandings.length === 2) {\n        // This is a 4-team tournament - go straight to final\n        const finalMatch = [\n          { \n            team1: groupAStandings[0].name, \n            team2: groupBStandings[0].name, \n            stage: \"Final\" \n          }\n        ];\n        \n        moveToStage(finalMatch, \"Final\");\n        return; // Exit early\n      } else {\n        // More than 4 teams - top 2 from each group\n        const groupA = groupAStandings.slice(0, 2);\n        const groupB = groupBStandings.slice(0, 2);\n        \n        semiFinals = [\n          { team1: groupA[0].name, team2: groupB[1].name, stage: \"Semi-Final 1\" },\n          { team1: groupB[0].name, team2: groupA[1].name, stage: \"Semi-Final 2\" }\n        ];\n      }\n    }\n    \n    moveToStage(semiFinals, \"Semi-Final\");\n  };\n\n  const generateFinal = (winners) => {\n    if (winners.length === 2) {\n      const finalMatch = [\n        { \n          team1: winners[0], \n          team2: winners[1], \n          stage: \"Final\" \n        }\n      ];\n\n      moveToStage(finalMatch, \"Final\");\n    } else {\n      alert(\"Error: Semi-final winners not properly tracked\");\n      onExit();\n    }\n  };\n\n  const handleShowStandings = () => {\n    setSummaryTab(0);\n    setShowTournamentSummary(true);\n  };\n\n  const handleShowStats = () => {\n    setSummaryTab(1);\n    setShowTournamentSummary(true);\n  };\n\n  const handleViewFinishedMatch = (matchKey) => {\n    setSimulationQueue([]);\n    setViewingMatchKey(matchKey);\n    setShowFixtures(false);\n  };\n\n  const handleSimulateTeamMatches = (teamName) => {\n    const hasMatchInProgress = scoreData.team1 && scoreData.team2 && !scoreData.gameover && !isSimulating;\n    if (hasMatchInProgress || isSimulating) return;\n\n    const remainingMatches = matches\n      .map((match, index) => ({ match, index }))\n      .filter(({ match, index }) => {\n        const isTeamMatch = match.team1 === teamName || match.team2 === teamName;\n        const isCompleted = Boolean(currentStageCompletedMatches[index]);\n        return isTeamMatch && !isCompleted;\n      })\n      .map(({ index }) => index);\n\n    if (remainingMatches.length === 0) return;\n\n    const [firstMatchIndex, ...restMatches] = remainingMatches;\n    setSimulationQueue(restMatches);\n    handleSimulateMatch(firstMatchIndex);\n  };\n\n  if (showTournamentSummary) {\n    return (\n      <div>\n        <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n          <Button\n            variant=\"outlined\"\n            style={{ color: \"whitesmoke\", position: \"absolute\", left: 20, top: 15 }}\n              onClick={() => setShowTournamentSummary(false)}\n            >\n              Back\n            </Button>\n          <h3>Tournament Summary</h3>\n        </div>\n        <Tabs\n          value={summaryTab}\n          onChange={(e, val) => setSummaryTab(val)}\n          style={{ backgroundColor: \"#333\" }}\n          variant=\"scrollable\"\n          scrollButtons=\"auto\"\n        >\n          <Tab label=\"Standings\" style={{ color: \"whitesmoke\" }} />\n          <Tab label=\"Stats\" style={{ color: \"whitesmoke\" }} />\n        </Tabs>\n        {summaryTab === 0 && <TournamentStandings standings={standings} stage=\"Tournament\" />}\n        {summaryTab === 1 && <StatsTab playerStats={playerStats} />}\n        <div style={{ textAlign: \"center\", marginTop: 20, paddingBottom: 20 }}>\n          <Button variant=\"outlined\" style={{ color: \"whitesmoke\" }} onClick={onExit}>\n            Exit Tournament\n          </Button>\n        </div>\n      </div>\n    );\n  }\n\n  // Show fixtures view\n  if (showFixtures) {\n    const hasMatchInProgress = scoreData.team1 && scoreData.team2 && !scoreData.gameover && !isSimulating;\n    \n    return (\n      <div>\n        <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n          <Button \n            variant=\"outlined\" \n            style={{ color: \"whitesmoke\", position: \"absolute\", left: 20, top: 15 }}\n            onClick={() => setShowFixtures(false)}\n          >\n            Back\n          </Button>\n          <h3>{currentStage}</h3>\n          <Button\n            variant=\"outlined\"\n            style={{ color: \"whitesmoke\", position: \"absolute\", right: 170, top: 15 }}\n            onClick={handleShowStandings}\n          >\n            Standings\n          </Button>\n          <Button\n            variant=\"outlined\"\n            style={{ color: \"whitesmoke\", position: \"absolute\", right: 20, top: 15 }}\n            onClick={handleShowStats}\n          >\n            Stats\n          </Button>\n          {isTournamentComplete && (\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              style={{ marginTop: 10 }}\n              onClick={handleShowStats}\n            >\n              View Tournament Stats\n            </Button>\n          )}\n          {hasMatchInProgress && (\n            <p style={{ color: \"#FFA726\", fontSize: \"0.9em\" }}>\n              Match in progress - complete or view current match before simulating others\n            </p>\n          )}\n        </div>\n        <FixturesView\n          matches={matches}\n          completedMatches={currentStageCompletedMatches}\n          currentMatchIndex={currentMatchIndex}\n          onSelectMatch={handleSelectMatch}\n          onSimulateMatch={handleSimulateMatch}\n          onViewFinishedMatch={handleViewFinishedMatch}\n          onSimulateTeamMatches={handleSimulateTeamMatches}\n          stage={currentStage}\n          simulatingMatchIndex={simulatingMatchIndex}\n          hasMatchInProgress={hasMatchInProgress}\n          finishedFixtures={finishedFixtures}\n          isSimulating={isSimulating}\n          playerStats={playerStats}\n        />\n      </div>\n    );\n  }\n\n  // Show post-match view for completed match being viewed\n  if (viewingMatchKey !== null && completedMatches[viewingMatchKey]) {\n    const matchData = completedMatches[viewingMatchKey];\n    return (\n      <div>\n        <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n          <Button \n            variant=\"outlined\" \n            style={{ color: \"whitesmoke\", position: \"absolute\", left: 20, top: 15 }}\n            onClick={() => {\n              setViewingMatchKey(null);\n              setShowFixtures(true);\n            }}\n          >\n            Back to Fixtures\n          </Button>\n          <h3>Match Details</h3>\n        </div>\n        <PostMatchView\n          standings={standings}\n          playerStats={playerStats}\n          currentStage={currentStage}\n          scoreData={matchData.scoreData}\n          teamData={teamData}\n          track={matchData.track}\n          onNextMatch={() => {\n            setViewingMatchKey(null);\n            setShowFixtures(true);\n          }}\n          onExit={onExit}\n          resultOverride={matchData.result}\n          showNextButton={false}\n          nextButtonText=\"\"\n        />\n      </div>\n    );\n  }\n\n  // Show match setup screen\n  if (matchSetupPending && currentMatchConfig) {\n    return (\n      <div>\n        <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n          <Button \n            variant=\"outlined\" \n            style={{ color: \"whitesmoke\", position: \"absolute\", left: 20, top: 15 }}\n            onClick={() => setShowFixtures(true)}\n          >\n            View Fixtures\n          </Button>\n          <h3>{currentMatchConfig?.stage || currentStage}</h3>\n          <p>Match {currentMatchIndex + 1} of {matches.length}</p>\n        </div>\n        <MatchSetup \n          match={currentMatchConfig}\n          onStartMatch={handleMatchStart}\n        />\n      </div>\n    );\n  }\n\n  // Show post-match view\n  if (scoreData.gameover && !isSimulating) {\n    const currentMatchKey = getMatchKey(currentStage, currentMatchIndex);\n    const currentMatchResult =\n      completedMatches[currentMatchKey]?.result ||\n      getTournamentOutcome(scoreData, currentStage).result;\n    return (\n      <div>\n        <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n          <Button \n            variant=\"outlined\" \n            style={{ color: \"whitesmoke\", position: \"absolute\", left: 20, top: 15 }}\n            onClick={() => setShowFixtures(true)}\n          >\n            View Fixtures\n          </Button>\n        </div>\n        <PostMatchView\n          standings={standings}\n          playerStats={playerStats}\n          currentStage={currentStage}\n          scoreData={scoreData}\n          teamData={teamData}\n          track={track}\n          onNextMatch={handleNextMatch}\n          onExit={onExit}\n          resultOverride={currentMatchResult}\n          showNextButton={true}\n          nextButtonText={\n            currentStage === \"Final\"\n              ? \"View Tournament Stats\"\n              : (currentMatchIndex < matches.length - 1 ? \"Next Match\" : \"View Final Standings\")\n          }\n        />\n      </div>\n    );\n  }\n\n  // Show live match view - only if match has started\n  if (scoreData.team1 && scoreData.team2 && !isSimulating) {\n    return (\n      <div>\n        <div style={{ textAlign: \"center\", padding: 10, color: \"whitesmoke\", backgroundColor: \"#333\" }}>\n          <Button \n            variant=\"outlined\" \n            style={{ color: \"whitesmoke\", position: \"absolute\", left: 20, top: 15 }}\n            onClick={() => setShowFixtures(true)}\n          >\n            View Fixtures\n          </Button>\n          <h3>{currentMatchConfig?.stage || currentStage}</h3>\n          <p>Match {currentMatchIndex + 1} of {matches.length}</p>\n        </div>\n        \n        <TournamentMatchView\n          pitchType={currentMatchConfig?.pitchType || \"Normal\"}\n          standings={standings}\n          playerStats={playerStats}\n          currentStage={currentStage}\n          scoreData={scoreData}\n          teamData={teamData}\n          isMatchOver={scoreData.gameover}\n        />\n      </div>\n    );\n  }\n\n  // Simulating state\n  if (isSimulating) {\n    return (\n      <div style={{ textAlign: \"center\", padding: 50, color: \"whitesmoke\" }}>\n        <h3>Simulating match...</h3>\n        <p>{scoreData.team1} vs {scoreData.team2}</p>\n      </div>\n    );\n  }\n\n  // Fallback - loading state\n  return (\n    <div style={{ textAlign: \"center\", padding: 50, color: \"whitesmoke\" }}>\n      <h3>Loading match...</h3>\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  scoreData: state.manageScores,\n  teamData: state.getTeams\n});\n\nconst mapDispatchToProps = (dispatch) => ({\n  pickTeamDispatch: (team1, team2, overs, format) => dispatch(pickTeams(team1, team2, overs, format)),\n  resetDispatch: () => dispatch(resetState()),\n  simulateMatchDispatch: (pitchType) => dispatch(simulateMatch(pitchType))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TournamentManager);\n","/Users/adityav/repos/book-cricket-react-redux/src/components/StatsTab.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentStandings.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/PostMatchView.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/MatchSetup.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/TournamentMatchView.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/SingleTeamScoreCard.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/helpers/matchResultHelper.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/components/FixturesView.js",[],"/Users/adityav/repos/book-cricket-react-redux/src/redux-setup/actions/simulateMatch.js",["164","165"],"import RandomWithIndex from \"../../helpers/improvedRandomNumber\";\n\nconst simulateMatch = (pitchType) => {\n  return (dispatch, getState) => {\n    const state = getState();\n    const { manageScores } = state;\n    const maxBalls = manageScores.overs * 6;\n\n    // Simulate entire first innings\n    while (\n      manageScores.team1Wickets < 10 &&\n      manageScores.team1BallsFaced < maxBalls\n    ) {\n      const gameState = {\n        ballsFaced: manageScores.team1BallsFaced,\n        currentScore: manageScores.team1Total,\n        targetScore: null,\n        wicketsLost: manageScores.team1Wickets,\n        batterIndex: manageScores.onStrike.batterIndex\n      };\n      \n      dispatch({ type: \"SCORE\", payload: { pitchType } });\n      \n      // Get updated state\n      const newState = getState().manageScores;\n      if (newState.team1Wickets >= 10 || newState.team1BallsFaced >= maxBalls) {\n        break;\n      }\n    }\n\n    // Complete first innings\n    dispatch({ type: \"COMPLETE\", payload: \"team1\" });\n\n    // Simulate entire second innings\n    const updatedState = getState().manageScores;\n    while (\n      updatedState.team2Wickets < 10 &&\n      updatedState.team2BallsFaced < maxBalls &&\n      updatedState.team2Total <= updatedState.team1Total\n    ) {\n      dispatch({ type: \"SCORE\", payload: { pitchType } });\n      \n      const newState = getState().manageScores;\n      if (\n        newState.team2Wickets >= 10 ||\n        newState.team2BallsFaced >= maxBalls ||\n        newState.team2Total > newState.team1Total\n      ) {\n        break;\n      }\n    }\n\n    // Complete second innings\n    dispatch({ type: \"COMPLETE\", payload: \"team2\" });\n  };\n};\n\nexport default simulateMatch;\n",{"ruleId":"166","replacedBy":"167"},{"ruleId":"168","replacedBy":"169"},{"ruleId":"170","severity":1,"message":"171","line":38,"column":6,"nodeType":"172","endLine":38,"endColumn":8,"suggestions":"173"},{"ruleId":"170","severity":1,"message":"174","line":114,"column":6,"nodeType":"172","endLine":114,"endColumn":23,"suggestions":"175"},{"ruleId":"176","severity":1,"message":"177","line":19,"column":7,"nodeType":"178","messageId":"179","endLine":25,"endColumn":8},{"ruleId":"176","severity":1,"message":"177","line":29,"column":7,"nodeType":"178","messageId":"179","endLine":35,"endColumn":8},{"ruleId":"176","severity":1,"message":"177","line":39,"column":7,"nodeType":"178","messageId":"179","endLine":46,"endColumn":8},{"ruleId":"166","replacedBy":"180"},{"ruleId":"168","replacedBy":"181"},{"ruleId":"182","severity":1,"message":"183","line":152,"column":7,"nodeType":"184","messageId":"185","endLine":152,"endColumn":27},{"ruleId":"170","severity":1,"message":"186","line":44,"column":6,"nodeType":"172","endLine":44,"endColumn":26,"suggestions":"187"},{"ruleId":"170","severity":1,"message":"188","line":253,"column":6,"nodeType":"172","endLine":253,"endColumn":112,"suggestions":"189"},{"ruleId":"170","severity":1,"message":"190","line":277,"column":6,"nodeType":"172","endLine":277,"endColumn":61,"suggestions":"191"},{"ruleId":"170","severity":1,"message":"192","line":284,"column":6,"nodeType":"172","endLine":284,"endColumn":37,"suggestions":"193"},{"ruleId":"182","severity":1,"message":"194","line":1,"column":8,"nodeType":"184","messageId":"185","endLine":1,"endColumn":23},{"ruleId":"182","severity":1,"message":"195","line":14,"column":13,"nodeType":"184","messageId":"185","endLine":14,"endColumn":22},"no-native-reassign",["196"],"no-negated-in-lhs",["197"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'dispatch', 'dynamicSquads', and 'props'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.","ArrayExpression",["198"],"React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["199"],"no-lone-blocks","Block is redundant.","BlockStatement","redundantBlock",["196"],["197"],"no-unused-vars","'getSituationModifier' is assigned a value but never used.","Identifier","unusedVar","React Hook useEffect has missing dependencies: 'config.numMatches', 'currentMatch', 'matchResults', 'matchSetupPending', 'scoreData', 'seriesScore.team1', and 'seriesScore.team2'. Either include them or remove the dependency array. You can also do a functional update 'setMatchResults(m => ...)' if you only need 'matchResults' in the 'setMatchResults' call.",["200"],"React Hook useEffect has missing dependencies: 'scoreData' and 'updateStandingsAndStats'. Either include them or remove the dependency array.",["201"],"React Hook useEffect has missing dependencies: 'generateFinal' and 'generateSemiFinals'. Either include them or remove the dependency array.",["202"],"React Hook useEffect has a missing dependency: 'handleSimulateMatch'. Either include it or remove the dependency array.",["203"],"'RandomWithIndex' is defined but never used.","'gameState' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"204","fix":"205"},{"desc":"206","fix":"207"},{"desc":"208","fix":"209"},{"desc":"210","fix":"211"},{"desc":"212","fix":"213"},{"desc":"214","fix":"215"},"Update the dependencies array to be: [dispatch, dynamicSquads, props]",{"range":"216","text":"217"},"Update the dependencies array to be: [props, props.scoreData]",{"range":"218","text":"219"},"Update the dependencies array to be: [config.numMatches, currentMatch, matchResults, matchSetupPending, scoreData, scoreData.gameover, seriesScore.team1, seriesScore.team2]",{"range":"220","text":"221"},"Update the dependencies array to be: [scoreData.gameover, matchSetupPending, matches.length, currentMatchIndex, currentStage, completedMatches, scoreData, updateStandingsAndStats]",{"range":"222","text":"223"},"Update the dependencies array to be: [completedMatches, matches, currentStage, isSimulating, generateSemiFinals, generateFinal]",{"range":"224","text":"225"},"Update the dependencies array to be: [handleSimulateMatch, isSimulating, simulationQueue]",{"range":"226","text":"227"},[1449,1451],"[dispatch, dynamicSquads, props]",[3839,3856],"[props, props.scoreData]",[1803,1823],"[config.numMatches, currentMatch, matchResults, matchSetupPending, scoreData, scoreData.gameover, seriesScore.team1, seriesScore.team2]",[8555,8661],"[scoreData.gameover, matchSetupPending, matches.length, currentMatchIndex, currentStage, completedMatches, scoreData, updateStandingsAndStats]",[9273,9328],"[completedMatches, matches, currentStage, isSimulating, generateSemiFinals, generateFinal]",[9565,9596],"[handleSimulateMatch, isSimulating, simulationQueue]"]